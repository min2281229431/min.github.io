import numpy as np
import scipy.stats as st
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns

"""
现有90台同类型的设备，各台设备的工作是相互独立的，发生故障的概率是0.01,且一台设备的故障能由一人处理，
配备维修工人的方法有两种，一种是3人分开维护，每人负责30台，另一种是由3人共同维护90台，
试比较两种方法在设备发生故障时不能及时维修的概率的大小.
（1）3人分别负责30台，发生故障时不能及时维修表明30台机器中发生故障的机器台数为2台及以上的概率。
（2）3人共同维护90台机器，则是90台机器中同时发生故障的机器超过4台及以上的概率。
（3）可以使用二项分布来求概率，由于计算的是随机变量大于某个值的概率分布(累计分布函数)，因此需要使用''生存函数''进行计算。
"""
# 一、使用生存函数
# 3人分别负责30台发生故障不能修理的概率  # P{X>1} = ?
p30 = st.binom.sf(k=1, p=0.01, n=30) * 3
# 3人共同负责90台发生故障不能修理的概率  # P{X>3} = ?
p90 = st.binom.sf(k=3, p=0.01, n=90)
print('p30 =', p30, '，p90 =', p90)
print('3人共同维护90台机器时,发生故障不能及时修理的概率更小。')

# 二、概率质量函数（分布律）
###下面两种计算方式的效果相同,pmf函数计算离散型随机变量的概率质量函数。
p30_1 = (1 - (st.binom.pmf(k=0, p=0.01, n=30) + st.binom.pmf(k=1, p=0.01, n=30))) * 3
print(p30_1)
# 三、累计分布函数
# cdf计算累积分布函数的值
p30_2 = (1 - st.binom.cdf(k=1, p=0.01, n=30)) * 3
print(p30_2)

# ==================================================================================================================== #
"""
  设1英尺长金属上有一个疤痕的概率是1/1000，并且为了实用，设1英尺长金属线上有两个或多个疤痕的概率为0，设随机变量X表示3000
英尺金属线上的疤痕数。如果我们假定非交叠区间上的疤痕是独立的，那么就接近于泊松过程的假设，其中（lambda）λ=1/1000而
（omega）ω=3000。因此，X大致服从均值为3000*(1/3000) = 3的泊松分布。3000英尺的金属线上有5个或更多疤痕的概率是
P(X>=5) = Σ (3**k * e**-3) / k! , k=5,6,...
（1）P(X>=5)的概率等于k=5到无穷的概率质量之和。可以用1-P(x<=4)来间接计算。
这里用到Scipy统计包的cdf函数，即"累计分布函数（Cumulative Distribution Function）"的英文缩写。
（2）直接通过生存函数sf也可以求P(X>=5)。sf是"生存函数（Survival Function）"的英文缩写。二者求解结果是一样的。
（3）cdf和sf两个函数后面会经常用到。对于相同分布的的相同随机变量，cdf+sf=1.
"""

### 1.通过累积分布函数间接求解

# mu表示均值，本例中等于3，下同。
p4 = st.poisson.cdf(k=4, mu=3)
p5 = 1 - p4
print('3000英尺的金属线上有5个及以上疤痕的概率是(通过累积分布函数)：', np.round(p5, 3))

### 2.通过生存函数直接求解
# 注意这里的k不是5而是4。
p5_1 = st.poisson.sf(k=4, mu=3)
print('\n3000英尺的金属线上有5个及以上疤痕的概率是(通过生存函数)：', np.round(p5_1, 3))
